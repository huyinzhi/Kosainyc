<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title函数调用栈分析</title>
</head>
<body>
    函数调用栈：羽毛球筒执行上下文：羽毛球创建阶段：放入羽毛球1)创建执行上下文对象functionEC = {        VO:{},            //自身属性（每个羽毛球独有）<br>        Scope Chain：[],  //相对属性（相对其他羽毛球）        this:{}           //相对属性}2)创建变量对象   羽毛球细分为羽毛和底座VO = {    arguments:{},               //获取函数参数对象    funcName:<pointer>,         //获取函数声明    variable:undefined          //获取变量声明}执行阶段：拿出栈顶的羽毛球准备使用VO → AO的过程可以想象成拿出羽毛球签名的过程，所有属性完成了赋值AO = {    arguments:{},    funcName:<pointer>,    variable:7,        //变量赋值    this:Window        //根据动态作用域决定指向，默认绑定在全局环境，可以理解为通过哪类快捷方式查找到了当前这个羽毛球                       //为什么这里突然会冒出this呢，因为只有执行了才能确定具体使用了哪种方式取球，这就是为什么在调用时才能确定this指向的原因}
实例分析：<br>


function test(){
        console.log(a);
        console.log(foo());
        var a = 1;
        function foo(){
            return 2;
        }
}
test();<br>

我的解析：<br>
1.test()调用启动test执行上下文，进入函数调用栈<br>
2.几乎同时，testEC 和 testVO 便创建完成<br>
3.进入testAO阶段，函数属性并未发生改变（因为没有新引用），参数对象也没有改变，发生变化的是变量赋值和添加this指向<br>

实际顺序：<br>


function test(){
        function foo(){
            return 2;
        }
        var a = undefined;
        console.log(a);
        console.log(foo());
        a = 1;
}
test();
</body>
</html>



